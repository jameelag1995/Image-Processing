# -*- coding: utf-8 -*-
"""Copy of IMPR Ex5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fHNU2BX57sECLW8cuHB7j2oWuB6neghn

# Important!
When initially opening the notebook there should be a text to the right of the "Help" menu saying "Changes will not be saved".
![WhatsApp Image 2021-01-02 at 22.02.20.jpeg](data:image/jpeg;base64,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qRaDjvZ0TszI8ppTC2UIde1TJRoSsiJSUJxIuJGZ4l0cV01e/H8C9b7P5x+QAAIUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIu2qP4tD66PUO2qP4tD66PUWgAIu2qP4tD66PUO2qP4tD66PUWgAIu2qP4tD66PUO2qP4tD66PUWgAIu2qP4tD66PUO2qP4tD66PUWgAIu2qP4tD66PUO2qP4tD66PUWgAIu2qP4tD66PUO2qP4tD66PUWgAIu2qP4tD66PUO2qP4tD66PUWgAIu2qP4tD66PUO2qP4tD66PUWj4debYQS3VZUmpKCPDHipRJIv+TIAS9tUfxaH10eodtUfxaH10eotAARdtUfxaH10eodtUfxaH10eotAARdtUfxaH10eodtUfxaH10eotAARdtUfxaH10eodtUfxaH10eotAARdtUfxaH10eodtUfxaH10eotAARdtUfxaH10eodtUfxaH10eotAARdtUfxaH10eodtUfxaH10eotAARdtUfxaH10eodtUfxaH10eotAARdtUfxaH10eodtUfxaH10eotAARdtUfxaH10eodtUfxaH10eotAARdtUfxaH10eodtUfxaH10eotAARdtUfxaH10eodtUfxaH10eotAARdtUfxaH10eodtUfxaH10eotAARdtUfxaH10eoC0AB5DNz0167ZdmIS92hDp0eqOGaS09F515tGB445szC8Sw+2HHiPVccQ02p1xRJQhJqUZ/sRfccYi7BG07TalU3a/fCaO7QoLDEwrwna7klMiUpxpSye1TQlC2lER/QRrUaeJqHZX2USGHI7pYodQaFf/AAywMZnpaL0c6iqlb4OM29tL2yXLRKVtPpNs0KXaNXmNaNGYZfVVypzj2mmXrZ9I1EkydNnS4IxLPiQ3ZW2TZsi6/wAlquUiqe+FTsd0f3YphliUbesmgT2H/iz58eGGI0Cyaftwsu1KHshpNnMMpoj7MFN2OTozkJdLbdI85R8+vvCmSyZDbJBLPHOZEPLc2c7SToL+x9FoJOmPXede/NW/saJQzqe/n/Cza+8l/KIsmT7Kz4cB0Wi5KMfhrrzSsc8G3e9arCRmVUm3np+rG26StqobVtA/ELbFAq0K17WqbE6tLuWm0KWh2DJVGb1pCEPNpkJJLJvoQs1ZNQ1JMvqSeBkNr/xf2dfm0rHK4i7WVJOCRbo/u5yiTmOPvOTQ1sOOlnz/ANBySVYe06BS4ezmHYD02HE2gtXIdfRUYiI7kFVU3xRm2pwntZBLNKk5MDJGKVKPBJ4rV2K12jXedKr9kXHWIbV1v1+LWSvZ5qkobXKVJbcVTyex3hClEnITGRRlmNZYmM9j3lFS1u/KHK7lnWncva91y0dWOc778RxtP6SAAAHkXVc9Ns+j9t1ZLxx96iQ8GUkpWpIkNsN8DMuGd1OPcWJ8fsPXHKNtWyJ296W7NpFRuVyou1ClLOHHuGTHiEy1MYU6smdVLRKS0hayMizZkkpP14DfrWtaHaVPcpsKp1mchx43zcqtUfnukZpSWUnHlKUSfpI8pHgRmZ4YmYA5/tuuja7ZEeLXrMrFoJpkmo02lFFqlFlSH0uypSGDc1W5baTSnUJWXJjwMs3HEvWnbUKZs2gxafteu2mvVt1tyUtVFokwmkRkqw1lspVIWy2n7KdcWSMceJfYZdtVsVy7bTgUy3oO9yWLho05xGqhvBhiey66vFZkX0oQo8McTwwIjPgNA2q7Lrkm7UJ15w7WuW5aXW6FHpS41Cu5yiuRnmXHj/jkT7KXmFk/xPFakmlWCDzDMW1H5ny0U19VVXgaaTddy56TT6XOl1LbBs5pCqgifcraFUxuC68lMd5xTiJissVTJJQZvk4r6SNrPxIy4GRkItmm16mbSq3dlFg0SqwVWvU9w1JdPlMJkI0m158XmWyQrFai08TVlSlf6VpMcxufZLe7t5WbdduWJBahbLYMGLTaYua2+urksiRIbS+4ojIoyCI2VPEk1Oko8CIyMdI2bUK5rdvfaEirUB1qm1ytorNPqJSGVNvIVEjsqaNBK1ErSplWOZJJMjLAzHSKWk67JdHGnNVfTJzbeitvd6p15Onup0URVb/Ko/3Mb/uQLRFVv8qj/cxv+5AyaLQAABzHa5trhbOZce2KTCZq111CBIqFPpa3jaJ9DOBqRmIjwWtJO6ZYHmU2aS4mQxfh6270vbvaT9aagIptUp8g486nk9q6WPFtZKwIzSpP74FxSov2xPiG1PZVtYt7blXdstEtx+856TjLthhTJrZjqNOC1OpJRESWUoUlKcxGpbqHP9Kx7P4VbF2kUzaFcF2Xbsrpdksyoytc4xS0KnPOuZsqW1yVtJSk0qM8qCwxSScCMwB2raLe1zUy47dsCxY1MVX7jKVJKVU0uLiwokZKDddW22pK3FGp1tCUEpOJqMzURFxnpe0mr2rRqs9tpjw6S/Sqi3AjzqfHfXHrBOoSppUVj+I8azNSkG0WdRKQeBmQ+NpVvXXGvW1dp9nULt6RQWZ1OnUpElqO9IiSiaM1srdNLeohxhB5VqSRpNX1EZFjrVbo22S5H6LtEqlqRzkW5cvaVOtQpkfeSgKhORlkqRm0Dk53VOkWfIRESc+PESLt5/8ASpT5eGa4VLL0tvs8+Lty233N7bnsuYoMK5F3I4cOoVJVGYQinSlyTnkhSzjKjpbN5DuVCvoUglfYsMVJI66Dtc2e3LJpkKkV5TkmsPy4sVh2FIYc14ySU+y4hxCVMuJSZKyOElRlxIjIhw266Ve9BuWg7QajZq26nc+0mPPjW63OYN5tlmjPxyJbpK0dZZNKWZEvJ+lOf7mXxtCtm9aRYlz7UJECNbl5VC8olbtylPym3nG3DZZp6WFqaUpCnXmzcMyQpRFnTxPAzBNtN02c2oW3/E8bN5H8SjX3WfJd1X3nbbg2u2zS9mNY2pUZMus02lsy1ITGhyDN91ha21JIktKWSNRBpN3KaCIjXjlLERJ29bPYttUG4a7Mn09yvQd/Zg9kzXZTbSSLUcWylnVS0kzw1VISgywMjwMhnkbN1UzYXK2VUA21PItl6jx1rPKTjyo6m86j/wDZZmoz/qY0Wh0nahadWpF9x9lkuqSJdoRLcm0gqpBRJp8mK64pKzcU7pLZc1DMzQs1llT9BniRV92Uo1qrUfCdebUfCq4q1jGSW2q4xpyTl40fDo9/32VD2SV/aRaUiDUdxoUir051Rm7GkZWTcbM8iiNSDwL7KLEj+5DV7f2gbRqDcFsUjad+XJ0G8mXCp9RosR+Ju0tDBv6DzLrr2YlNpcNK0rLigyNPEjE/+F9z0n8LVR2VsNMz7gdtmdCQyw4lDSpT6HDJpC1mkiQSnMiTVgWBEZ4Cel0HaJflwWZJuWw5Fp0iyG3JWSfPiyJVQnKiLjIJCYzjiENJS44o1KWSjPKWUixMSbcHPRvSlPqrxxjXTUyZjH5ufd0eGeFdh7MXb7YlyM0Or2hdDbtKnz1x3HZFDqGMtCYr75oiq00kbhEyZmeCiLIpGBLNJDZ07UbBWzSZJXJHSxW6S9XITykLS2qA0lCnH1qNODSCJ1v9Zp/Vh9yMi5naezO9abZuw6kT6ITcmz5ZOVtveWVbqjs+SzjiSjJz+I6hP0Gr74/YjMa7F/Dtes22tpVrzno8Vp2nu27Zbhv/AElTTfclkSzQZqbI1uoYPgSsscjIsMMdT7sppYVacF1rJqiWpSyaV3GuunWT5Uir72sHbrM2n2RtAelxbWqzr8iEht15iTBkRHSacx03UofQhS21ZTyuJI0ngeBjahx/Y1ZE2l3DLues7P7loVQ7Mbpxyq9ebtbddLUzrbZSbzyUMkoiMlGpCjMz+guI7ALJJUp7uYi26192AAAyaAAAAAAAAAAAAAAAAAAAAi0qxz8Pyi/cDSrHPw/KL9wAWgItKsc/D8ov3A0qxz8Pyi/cAFoCLSrHPw/KL9wNKsc/D8ov3ABaAi0qxz8Pyi/cDSrHPw/KL9wAWgItKsc/D8ov3A0qxz8Pyi/cAFoCLSrHPw/KL9wNKsc/D8ov3ABaAi0qxz8Pyi/cDSrHPw/KL9wAWiWoMuPx0IaTmUT7KzLHDgl1KjP/AIIx8aVY5+H5RfuBpVjn4flF+4ALQEWlWOfh+UX7gaVY5+H5RfuAC0BFpVjn4flF+4GlWOfh+UX7gAtARaVY5+H5RfuBpVjn4flF+4APubSqXUnYj9RpsWU5Af3mIt5lK1R3sqk6jZmX0KyrUnMWB4KMv3MYqhQKFVpsGo1SiwJkuluKegvyIyHHIrhlgamlKIzQoy4GacDwH1pVjn4flF+4GlWOfh+UX7gAtARaVY5+H5RfuBpVjn4flF+4ALQEWlWOfh+UX7gaVY5+H5RfuAC0BFpVjn4flF+4GlWOfh+UX7gAtARaVY5+H5RfuBpVjn4flF+4ALQEWlWOfh+UX7gaVY5+H5RfuAC0BFpVjn4flF+4GlWOfh+UX7gAtARaVY5+H5RfuBpVjn4flF+4ALQEWlWOfh+UX7gaVY5+H5RfuAC0BFpVjn4flF+4GlWOfh+UX7gAtARaVY5+H5RfuAALQHwbhEPzVLvAGQBj1S7w1S7wBkAY9Uu8NUu8AZAGPVLvDVLvAGQBj1S7w1S7wBkAY9Uu8NUu8AZAGPVLvDVLvAGQBj1S7w1S7wBkAY9Uu8NUu8AZAGPVLvDVLvAGQBj1S7w1S7wBkAY9Uu8NUu8AZAGPVLvDVLvAGQBj1S7w1S7wBkAY9Uu8NUu8AZAGPVLvDVLvAGQBj1S7w1S7wBkAY9Uu8NUu8AZAGPVLvDVLvAGQBj1S7w1S7wBkAY9Uu8NUu8AZAGPVLvAAatPuhbMlbDcclEg8Mxqwx/8AzAS/mqRy5f3fAAAH5pkcun+74D80yOXT/d8AAAfmmRy6f7vge/SykVKC1N10t6mb6cmOGBmX3x/oAACrcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyG4SOcT0vkAADcJHOJ6XyAAAP/9k=)

To ensure you can make changes to the notebook save a copy of it to your own drive and work on that one. You can do that by going to "File" -> "Save a copy in Drive".

**Failing to do so will result in code loss!**

 **Note** Make sure you are the only one that has access to it!
"""

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 1.14

"""###Version 1.2 - Last Update 10.01.2021
**Changelog:** 
* Changed the `effect_of_depth` section as per the updated PDF

**Version 1.1 - 07.01.2021 Changelog:** 
* Added tensorflow version code block
"""

# Commented out IPython magic to ensure Python compatibility.
# @markdown #Image Processing - 67829. { display-mode: "form" }
# @markdown ##Exercise 5: Neural Networks for Image Restoration
# @markdown ##Due date: 21.01.2021 at 23:59
# @title{ display-mode: "form" }
# @markdown Please enter your cs username:
cs_id = "jameelag"  # @param {type:"string"}
# @markdown **Make sure the username you typed is correct before you proceed.**
# @markdown
# @markdown
# @markdown This exercise deals with neural networks and their application to image restoration.
# @markdown In this exercise you will develop a general workflow for training networks to restore corrupted images,
# @markdown and then apply this workflow on two different tasks: (i) image denoising, and (ii) image deblurring.
# @markdown
# @markdown
# @markdown Before you start working on the exercise it is recommended that you review the lecture slides covering neural networks,
# @markdown and how to implement them using the Keras framework. To recap the relevant part of the lecture: there are many possible
# @markdown ways to use neural networks for image restoration.
# @markdown
# @markdown The method you will implement consists of the following three steps:
# @markdown
# @markdown 1. Collect "clean" images, apply simulated random corruptions, and extract small patches.
# @markdown 2. Train a neural network to map from corrupted patches to clean patches.
# @markdown 3. Given a corrupted image, use the trained network to restore the complete image by restoring each patch separately, by applying the "ConvNet Trick" for approximating this process as learned in class.
# @markdown
# @markdown **NOTE**: Neural networks are typically trained on GPUs, without GPUs training takes much longer.
# @markdown To enable GPU tranining click on "Runtime" -> "Change runtime type" -> "GPU" -> "SAVE".

# @markdown **NOTE**: A short guide on debugging your code using colab is availble [here](https://colab.research.google.com/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/01.06-Errors-and-Debugging.ipynb#scrollTo=qnIn-rWFqoww).

# @markdown But first, we have to download the dataset. Play this cell to download it and get everything ready.
# @markdown This may take a few minutes.


import re
import os, itertools, random
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import numpy as np
import pandas as pd
from tqdm import tqdm
from glob import glob
from PIL import Image
from skimage.draw import line

# sklearn libraries
from sklearn.metrics import confusion_matrix
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
import json

from imageio import imread
from skimage.color import rgb2gray
from tensorflow.keras.layers import Input, Conv2D, Activation, Add, UpSampling2D, Dense, Flatten, Reshape, \
    AveragePooling2D
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from scipy.ndimage.filters import convolve
import matplotlib.pyplot as plt
from scipy.ndimage import zoom
from skimage import color


########## Register student ID ##########

# regex=re.compile(r'^\d+$')
# assert regex.match(id_num), "Please write your ID number in the corresponding field"
# with open(f"{id_num}.json", "w") as write_file:
#     json.dump({}, write_file)

# def write_json(key, values):
#   r=np.random.randint(1e7)
#   values.update({"r":r})
#   with open(f"{id_num}.json", "r") as file:
#     data = json.load(file)
#   if key in data.keys():
#     for k, v in values.items():
#       data[key][k].append(v)
#   else:
#     data[key] = {k:[v] for k, v in values.items()}
#   with open(f"{id_num}.json", "w") as file:
#     json.dump(data, file)

########## End of register student ID ##########

########## Utils ##########

def relpath(path):
    """Returns the relative path to the script's location

    Arguments:
    path -- a string representation of a path.
    """
    return os.path.join(os.getcwd(), path)


def list_images(path, use_shuffle=True):
    """Returns a list of paths to images found at the specified directory.

    Arguments:
    path -- path to a directory to search for images.
    use_shuffle -- option to shuffle order of files. Uses a fixed shuffled order.
    """

    def is_image(filename):
        return os.path.splitext(filename)[-1][1:].lower() in ['jpg', 'png']

    images = list(map(lambda x: os.path.join(path, x), filter(is_image, os.listdir(path))))
    # Shuffle with a fixed seed without affecting global state
    if use_shuffle:
        s = random.getstate()
        random.seed(1234)
        random.shuffle(images)
        random.setstate(s)
    return images


def images_for_denoising():
    """Returns a list of image paths to be used for image denoising in Ex5"""
    return list_images(relpath("current/image_dataset/train"), True)


def images_for_deblurring():
    """Returns a list of image paths to be used for text deblurring in Ex5"""
    return list_images(relpath("current/text_dataset/train"), True)


def images_for_super_resolution():
    """Returns a list of image paths to be used for image super-resolution in Ex5"""
    return list_images(relpath("current/image_dataset/train"), True)


def motion_blur_kernel(kernel_size, angle):
    """Returns a 2D image kernel for motion blur effect.

    Arguments:
    kernel_size -- the height and width of the kernel. Controls strength of blur.
    angle -- angle in the range [0, np.pi) for the direction of the motion.
    """
    if kernel_size % 2 == 0:
        raise ValueError('kernel_size must be an odd number!')
    if angle < 0 or angle > np.pi:
        raise ValueError('angle must be between 0 (including) and pi (not including)')
    norm_angle = 2.0 * angle / np.pi
    if norm_angle > 1:
        norm_angle = 1 - norm_angle
    half_size = kernel_size // 2
    if abs(norm_angle) == 1:
        p1 = (half_size, 0)
        p2 = (half_size, kernel_size - 1)
    else:
        alpha = np.tan(np.pi * 0.5 * norm_angle)
        if abs(norm_angle) <= 0.5:
            p1 = (2 * half_size, half_size - int(round(alpha * half_size)))
            p2 = (kernel_size - 1 - p1[0], kernel_size - 1 - p1[1])
        else:
            alpha = np.tan(np.pi * 0.5 * (1 - norm_angle))
            p1 = (half_size - int(round(alpha * half_size)), 2 * half_size)
            p2 = (kernel_size - 1 - p1[0], kernel_size - 1 - p1[1])
    rr, cc = line(p1[0], p1[1], p2[0], p2[1])
    kernel = np.zeros((kernel_size, kernel_size), dtype=np.float64)
    kernel[rr, cc] = 1.0
    kernel /= kernel.sum()
    return kernel


def read_image(filename, representation):
    """Reads an image, and if needed makes sure it is in [0,1] and in float64.
    arguments:
    filename -- the filename to load the image from.
    representation -- if 1 convert to grayscale. If 2 keep as RGB.
    """
    im = imread(filename)
    if representation == 1 and im.ndim == 3 and im.shape[2] == 3:
        im = color.rgb2gray(im).astype(np.float64)
    if im.dtype == np.uint8:
        im = im.astype(np.float64) / 255.0
    return im


########## End of utils ##########

########## Download datasets ##########

# !mkdir current
# # %cd current
# !wget --load-cookies /tmp/cookies.txt "https://www.cs.huji.ac.il/~impr/datasets.tar" -O datasets.tar && rm -rf /tmp/cookies.txt
# !tar -xvf datasets.tar
# !unzip image_dataset.zip
# !unzip text_dataset.zip
# !rm -f datasets.tar
# !rm -f image_dataset.zip
# !rm -f text_dataset.zip
# # %cd ..
# !wget --load-cookies /tmp/cookies.txt "https://www.cs.huji.ac.il/~impr/requirements.txt" -O requirements.txt && rm -rf /tmp/cookies.txt
# !pip install -r requirements.txt

########## End of download datasets ##########

"""# 3 Dataset Handling"""

GS = 1
RGB = 3
MAX_VALUE = 256
SUB_VAL = 0.5
CONVOLUTION_KER = 3
TRAINING_IMAGES_PERC = 0.8

MIN_SIGMA = 0
MAX_SIGMA = 0.2
PATCH = 24
CHANNELS = 48
BATCH_SIZE = 100
STEPS_PER_EPOCH = 100
NUM_OF_EPOCHS = 10
NUM_OF_VALID_SAMPLES = 1000

DBM_KER = 7
DBM_PATCH_SIZE = 16
DBM_CHANNELS = 32
DBM_BATCH_SIZE = 100
DBM_STEPS_PER_EPOCH = 100
DBM_EPOCHS = 10
DBM_VALID_SAMPLES = 1000


def load_dataset(filenames, batch_size, corruption_func, crop_size):
    """
    A generator for generating pairs of image patches, corrupted and original
    :param filenames: a list of filenames of clean images.
    :param batch_size: The size of the batch of images for each iteration of Stochastic Gradient Descent.
    :param corruption_func: A function receiving a numpy array representation of an image as a single argument, and returning a randomly corrupted version of the input image.
    :param crop_size: A tuple (height, width) specifying the crop size of the patches to extract.
    :return:outputs random tuples of the form (source_batch, target_batch), where each output variable is an array of shape(batch_size, height, width, 1).
     target_batch is made of clean images and source_batch is their respective randomly corrupted version
     according to corruption_func(im)
    """

    img_dict = {}
    num_of_images = len(filenames)

    while True:
        s_batch = []
        t_batch = []
        curr_size = 0
        while curr_size < batch_size:
            rnd_index = np.random.randint(num_of_images)
            # Load Image
            if filenames[rnd_index] not in img_dict:
                img_dict[filenames[rnd_index]] = read_image(filenames[rnd_index], GS)

            img = img_dict[filenames[rnd_index]]
            # generate random large crop
            temp_row = np.random.randint(img.shape[0] - 3 * crop_size[0])
            temp_col = np.random.randint(img.shape[1] - 3 * crop_size[1])
            # corrupt original image
            crop_3x_img = img[temp_row:temp_row + 3 * crop_size[0], temp_col:temp_col + 3 * crop_size[1]]
            corrupt_img = corruption_func(crop_3x_img)
            # crop source and target images substract 0.5 from each pixel
            temp_row = np.random.randint(crop_3x_img.shape[0] - crop_size[0])
            temp_col = np.random.randint(crop_3x_img.shape[1] - crop_size[1])
            corp_s_img = corrupt_img[temp_row:temp_row + crop_size[0], temp_col:temp_col + crop_size[1]]
            s_img = corp_s_img - SUB_VAL
            t_img = crop_3x_img[temp_row:temp_row + crop_size[0], temp_col:temp_col + crop_size[1]]
            t_img = t_img - SUB_VAL
            # append images to batch
            t_batch.append(t_img[..., np.newaxis])
            s_batch.append(s_img[..., np.newaxis])
            curr_size += 1

        yield np.array(s_batch), np.array(t_batch)


"""# 4 Neural Network Model"""


def resblock(input_tensor, num_channels):
    """
    Takes as input a symbolic input tensor and the number of channels for each of its convolutional layers, and returns the symbolic output tensor of the resnet block.
    The convolutional layers should use “same” border mode, so as to not decrease the spatial dimension of the output tensor.
    :param input_tensor: input tensor
    :param num_channels: number of channels
    :return: symbolic output tensor of the resnet block
    """
    layer_1 = Conv2D(num_channels, (CONVOLUTION_KER, CONVOLUTION_KER), padding='same')(input_tensor)
    layer_2 = Activation('relu')(layer_1)
    layer_3 = Conv2D(num_channels, (CONVOLUTION_KER, CONVOLUTION_KER), padding='same')(layer_2)
    layer_4 = Add()([layer_3, input_tensor])
    output = Activation('relu')(layer_4)

    return output


def build_nn_model(height, width, num_channels, num_res_blocks):
    """
    Create an untrained Keras model with input dimension the shape of (height, width, 1), and all convolutional layers (including residual
    blocks) with number of output channels equal to num_channels, except the very last convolutional layer which should have a single output channel.
    The number of residual blocks should be equal to num_res_blocks.
    :param height: height
    :param width: width
    :param num_channels: number of channels
    :param num_res_blocks: number of residual blocks
    :return: an untrained Keras model.
    """
    my_input = Input(shape=(height, width, GS))
    layer_1 = Conv2D(num_channels, (CONVOLUTION_KER, CONVOLUTION_KER), padding='same')(my_input)
    layer_2 = Activation('relu')(layer_1)
    N_input = layer_2
    for i in range(num_res_blocks):
        N_input = resblock(N_input, num_channels)

    res = Add()([my_input, N_input])
    final_output = Conv2D(GS, (CONVOLUTION_KER, CONVOLUTION_KER), padding='same')(res)
    my_model = Model(my_input, final_output)

    return my_model


"""# 5 Training Networks for Image Restoration"""

TRAINING_IMAGES_PERC = 0.8


def train_model(model, images, corruption_func, batch_size, steps_per_epoch, num_epochs, num_valid_samples):
    """
    Divide the images into a training set and validation set, using an 80-20 split, and generate from each set a dataset with the given batch size
    and corruption function. Eventually it will train the model.
    :param model:  a general neural network model for image restoration.
    :param images: a list of file paths pointing to image files. You should assume these paths are complete, and should append anything to them.
    :param corruption_func: a corruption function.
    :param batch_size: the size of the batch of examples for each iteration of SGD.
    :param steps_per_epoch: the number of update steps in each epoch.
    :param num_epochs: the number of epochs for which the optimization will run.
    :param num_valid_samples: the number of samples in the validation set to test on after every epoch.
    """
    split_index = int(len(images) * TRAINING_IMAGES_PERC)
    training_images = images[:split_index]
    validation_images = images[split_index:]
    # generate dataset
    crop_size = model.inputs[0].shape[1:3]
    training_generator = load_dataset(training_images, batch_size, corruption_func, crop_size)
    valid_generator = load_dataset(validation_images, batch_size, corruption_func, crop_size)

    # compile model
    model.compile(loss='mean_squared_error', optimizer=Adam(beta_2=0.9))

    model.fit_generator(training_generator, steps_per_epoch=steps_per_epoch, epochs=num_epochs,
                        validation_data=valid_generator, validation_steps=num_valid_samples, use_multiprocessing=False)


"""# 6 Image Restoration of Complete Images"""


def restore_image(corrupted_image, base_model):
    """
    Restore full images of any size
    :param corrupted_image: a grayscale image of shape (height, width) and with values in the [0, 1] range of type float64 that is affected
    by a corruption generated from the same corruption function encountered during training (the image is not necessarily from the training set though).
    :param base_model: a neural network trained to restore small patches. The input and output of the network are images with values in the [−0.5, 0.5] range.
    :return: the restored image
    """
    img_height, image_width = corrupted_image.shape
    network_input = Input(shape=(img_height, image_width, GS))
    layer_1 = base_model(network_input)
    curr_model = Model(network_input, layer_1)
    weights = base_model.get_weights()
    curr_model.set_weights(weights)

    corrupt_image_shifted = corrupted_image - SUB_VAL
    # add grayscale channel to img for compatible shapes
    corrupt_image_shifted = corrupt_image_shifted[..., np.newaxis]
    restored_img = curr_model.predict(corrupt_image_shifted[np.newaxis, ...])[0]
    # remove channel restore original shape
    restored_img = restored_img[:, :, 0]
    restored_img = restored_img + SUB_VAL
    restored_img = np.clip(restored_img, 0, 1)

    return restored_img.astype(np.float64)


"""# 7 Application to Image Denoising and Deblurring
## 7.1 Image Denoising
### 7.1.1 Gaussian Noise
"""


def add_gaussian_noise(image, min_sigma, max_sigma):
    """
    Add random gaussian noise to an image
    :param image: a grayscale image with values in the [0, 1] range of type float64.
    :param min_sigma: a non-negative scalar value representing the minimal variance of the gaussian distribution.
    :param max_sigma: a non-negative scalar value larger than or equal to min_sigma, representing the maximal variance of the gaussian distribution
    :return: the corrupted image
    """
    rnd_sigma = np.random.uniform(min_sigma, max_sigma)
    rnd_noise = np.random.normal(0, rnd_sigma, image.shape)
    gn_img = image + rnd_noise
    gn_img = np.divide(np.round(gn_img * (MAX_VALUE - 1)), (MAX_VALUE - 1))
    corrupted_img = np.clip(gn_img, 0, 1)
    return corrupted_img


# @markdown ### 7.1.2 Training a Denoising Mode

denoise_num_res_blocks = 7  # @param {type:"slider", min:1, max:15, step:1}
# @markdown **DON'T FORGET TO RUN THIS CELL AFTER CHANGING IT!**




def learn_denoising_model(denoise_num_res_blocks, quick_mode=False):
    """
    Train a denoising model
    :param denoise_num_res_blocks: number of residual blocks
    :param quick_mode: is quick mode
    :return: the trained model
    """
    images = images_for_denoising()
    model = build_nn_model(PATCH, PATCH, CHANNELS, denoise_num_res_blocks)

    def corruption_function(image):
        return add_gaussian_noise(image, MIN_SIGMA, MAX_SIGMA)

    if quick_mode:
        train_model(model, images, corruption_function, batch_size=10, steps_per_epoch=3, num_epochs=2,
                    num_valid_samples=30)
    else:
        train_model(model, images, corruption_function, batch_size=100, steps_per_epoch=100, num_epochs=10,
                    num_valid_samples=1000)

    return model


"""## 7.2 Image Deblurring
### 7.2.1 Motion Blur
"""


def add_motion_blur(image, kernel_size, angle):
    """
    Simulate motion blur on the given image using a square kernel of size kernel_size where the line has the given angle in radians, measured relative to the positive horizontal axis.
    :param image: a grayscale image with values in the [0, 1] range of type float64.
    :param kernel_size:  an odd integer specifying the size of the kernel.
    :param angle: an angle in radians in the range [0, π).
    :return: blurred image
    """
    ker = motion_blur_kernel(kernel_size, angle)
    corrupt_img = convolve(image, ker)
    return corrupt_img


def random_motion_blur(image, list_of_kernel_sizes):
    """
    Simulate motion blur on the given image using a square kernel of size kernel_size where the line has the given angle in radians, measured relative to the positive horizontal axis.
    :param image: a grayscale image with values in the [0, 1] range of type float64.
    :param list_of_kernel_sizes: a list of odd integers.
    :return: blurred image
    """
    rnd_angle = np.random.uniform(0, np.pi)
    rnd_index = np.random.randint(len(list_of_kernel_sizes))
    ker_size = list_of_kernel_sizes[rnd_index]
    corrupt_img = add_motion_blur(image, ker_size, rnd_angle)
    return corrupt_img


# @markdown ### 7.2.2 Training a Deblurring Model


deblur_num_res_blocks = 7  # @param {type:"slider", min:1, max:15, step:1}


# @markdown **DON'T FORGET TO RUN THIS CELL AFTER YOU CHANGING THE VALUE!**

def learn_deblurring_model(deblur_num_res_blocks, quick_mode=False):
    """
    Train a deblurring model
    :param deblur_num_res_blocks: number of residual blocks
    :param quick_mode: is quick mode
    :return: the trained model
    """
    images = images_for_deblurring()
    model = build_nn_model(DBM_PATCH_SIZE, DBM_PATCH_SIZE, DBM_CHANNELS, deblur_num_res_blocks)

    def corruption_function(image):
        return random_motion_blur(image, [DBM_KER])

    if quick_mode:
        train_model(model, images, corruption_function, batch_size=10, steps_per_epoch=3, num_epochs=2,
                    num_valid_samples=30)
    else:
        train_model(model, images, corruption_function, DBM_BATCH_SIZE, DBM_STEPS_PER_EPOCH,
                    DBM_EPOCHS, DBM_VALID_SAMPLES)

    return model


"""##7.3 Image Super-resolution
### 7.3.1 Image Low-Resolution Corruption
**Note:** Make sure your implementation covers different LR scales, for simplicity you may assume we won't test your network on images which are of more than $4$ times lower in quality compared to the HR one.

**Hint:** The `scipy.ndimage.zoom` function may come in handy.

"""


def super_resolution_corruption(image):
    """
    Perform the super resolution corruption
    :param image: a grayscale image with values in the [0, 1] range of type float64.
    :return: corrupted image
    """
    rnd = np.random.choice([2, 3, 4])
    zoom_out = zoom(image, 1 / rnd)
    zoom_in = zoom(zoom_out, rnd)
    corrupted = zoom_in[:(image.shape[0] // rnd) * rnd, :(image.shape[1] // rnd) * rnd]

    return corrupted


# @markdown ### 7.3.2 Training a Super Resolution Model


super_resolution_num_res_blocks = 7  # @param {type:"slider", min:1, max:15, step:1}
batch_size = 64  # @param {type:"slider", min:1, max:128, step:16}
steps_per_epoch = 100  # @param {type:"slider", min:100, max:5000, step:100}
num_epochs = 10  # @param {type:"slider", min:1, max:20, step:1}
patch_size = 20  # @param {type:"slider", min:8, max:32, step:2}
num_channels = 32  # @param {type:"slider", min:16, max:64, step:2}

# @markdown **DON'T FORGET TO RUN THIS CELL AFTER YOU CHANGING THE VALUES!**

validation_samples = 1000


def learn_super_resolution_model(super_resolution_num_res_blocks, quick_mode=False):
    """
    Train a super resolution model
    :param super_resolution_num_res_blocks: number of residual blocks
    :param quick_mode: is quick mode
    :return: the trained model
    """
    images = images_for_super_resolution()
    model = build_nn_model(patch_size, patch_size, num_channels, super_resolution_num_res_blocks)

    def corruption_function(image):
        return super_resolution_corruption(image)

    if quick_mode:
        train_model(model, images, corruption_function, 10, 3, 2, 30)
    else:
        train_model(model, images, corruption_function, batch_size, steps_per_epoch,
                    num_epochs, validation_samples)

    return model


# @markdown **Question 1:** Give a short description of your implementation and explain why do you think it works and why is it a good method for training the SR task.
Answer1 = "In SR model I start by making  the image smaller using zoom function with factor of 2,3 or 4 and then I make it larger by the same factor that way we lose some information from the given image which is ideal for training SR model (after making sure that the original image and corrupted one are same shape). I think this is a good method because the NN even after missing some info from the input image can still create  and retrun way better looking image than LR (corrupt) image we had."  # @param {type:"string"}
with open(f'answer_q1.txt', 'w+') as fh:
    fh.write(Answer1)

# @markdown **DON'T FORGET TO RUN THIS CELL AFTER YOU ANSWER IT!**

# @markdown **Question 2:** Elaborate on the different parameters you've tried to use and how did changing them affect the training process, finally list the parameters you've chosen.
Answer2 = "I started with the parameters used in denoise and deblur which didn't give a good results and the graphs function derivatives where not continuous, but i noticed that the more residual blocks I had the image looked sharper so I increased it to 7 after that I started trying out different epochs the more the better so I chose 12 epochs (didn't have much time to try more) and finally I changed the size of the patch and number of channels to 20 and 32 respectively which made the valid loss graph look smoother. so my final parameters are num_res_block 7 epochs 12 patch 20 and num of channels 32."  # @param {type:"string"}
with open(f'answer_q2.txt', 'w+') as fh:
    fh.write(Answer2)

# @markdown **DON'T FORGET TO RUN THIS CELL AFTER YOU ANSWER IT!**

"""##7.4 Effect of depth
Use the `denoise_num_res_blocks` and `deblur_num_res_blocks` parameters to test models of different depths for the above tasks (only denoising and debluring). Produce a plot of the mean square error on the validation set with respect to the number of residual blocks (from 1 to 5). 

(the $X$ axis should be the number of epochs, the $Y$ axis should be the MSE value, and the graph should have $5$ functions, one for each depth). 

You do not need to submit the function that generates these plots, you should just submit them as part of your final submission.

**Note:** In your submission, the names of the plots should be `depth\_plot\_denoise.png` and  `depth\_plot\_deblur.png` and they should be located in the same directory as the rest of your files.
"""
# plotting
# plt.plot(all_models[0].history.history['val_loss'], color='b', label='1')
# plt.plot(all_models[1].history.history['val_loss'], color='g', label='2')
# plt.plot(all_models[2].history.history['val_loss'], color='r', label='3')
# plt.plot(all_models[3].history.history['val_loss'], color='y', label='4')
# plt.plot(all_models[4].history.history['val_loss'], color='c', label='5')
# plt.title('Super Resolution Validation Loss')
# plt.ylabel('loss')
# plt.xlabel('epoch')
# plt.legend(title='num of res blocks', loc='upper right')
# plt.savefig('depth_plot_super_resolution.png')
# plt.show()

# @markdown **Question 3:** Describe the effect of increasing the residual blocks on its performance for each task, both quantitatively in terms of the plot you got and qualitatively in terms of the differences in the image outputs of each model.
Answer3 = "the more residual blocks I had the better images I got overall sharper and crisper images in deblur which makes it look almost similar to the orignal image, in denoise small parts of the image look more accurate meaning that the more res blocks less noise in the corrupt image but still not as good as the oirginal image , in SR it was more related to how much data the image had lost (which is related to the factor used to zoom out and zoom in) since it was chosen randomly it was a bit hard to notice the difference between different num of residual blocks but in the other hand there was a huge difference (better) with number of residual blocks larger than 1 compared to nn with 1 res block."  # @param {type:"string"}
with open(f'answer_q3.txt', 'w+') as fh:
    fh.write(Answer3)

# @markdown **DON'T FORGET TO RUN THIS CELL AFTER YOU ANSWER IT!**

"""#6. Bonus (+10): Deep Image Prior
For this section, you should read the article (you can download it from here: [arXiv](https://arxiv.org/abs/1711.10925), and implement the alternative method they propose for image restoration.

Specifically, implement the method described in the sub section titled |"Denoising and generic reconstruction"
"""


def deep_prior_restore_image(corrupted_image):
    """
    Implementation of the paper on deep prior image restoration for images of size 64x64
    :param corrupted_image: the 64 by 64 corrupted image
    :return: a restored image
    """
    pass


"""**Note:** In your function you are free to use either the models used in the rest of this assignment or experiment with your own models (or ones suggested in the article). 

Due to computational constraints, you can assume that we will test this function with images which are exactly 64-by-64 pixels. Naturally, due to runtime constraints you might not be able to get to results as good as the ones presented by the authors, however, you should be able to reproduce the underlying effect.

#9. Tips & Guidelines
* For your connivance, some of the functions include "sliders" that let you play with some hyper parameters. If you don't want to use them you are welcome to "override" the values they use and assign values programmatically.  
*   Do not forget to answer **Question 1** and **Question 2** from section 7.3.
*   Do not forget to answer **Question 3** from section 7.4, and to produce the required plots.
*   You are only allowed to use the Tensorflow. Keras framework for implementing neural networks. Do not use ``vanila'' Tensorflow directly. It is okay to use additional functions when implementing the bonus.
*   Be sure to implement quick mode in such a way that testing under this configuration use the exact same methods as the regular mode with the exception of different parameters. We suggest you define the parameters using local variables conditionally on `quick_mode`, and then use them throughout the rest of your learning methods.
*   You may assume **legal input** to all functions.
*   All input images are represented by a matrix of class `np.float64`.
*   Avoid unnecessary loops in your code, e.g. for pixel-wise operations. You can loop over images in a batch in the `load_dataset` function. You can loop over number of residual blocks when building the model.

# 10. Submission
Lucky for us, colab has an easy way of exporting your notebook code to a python file:

Once downloaded, treat your python script the same way you would any other exercise so far.
Submit your exercise via git and ensure that the presubmission script passes succesfully.
![Screenshot_2020-12-30_16-07-28.png](data:image/png;base64,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)
"""

# @markdown #10.1. Download outputs

# @markdown Playing this cell will create a zip file with your username on it and downloads it.

# @markdown Download your answers and outputs and add them to your git project.
# !zip {cs_id}.zip *.png answer*.txt
